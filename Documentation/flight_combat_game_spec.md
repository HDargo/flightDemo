# 대규모 비행 전투 게임 개발 지시사항

## 프로젝트 개요
Godot 4 엔진을 사용한 대규모 비행기 전투 게임 개발. PackedVector3Array, GPU Instancing, GLSL Compute Shader를 활용하여 수백~수천 개의 유닛을 동시에 처리.

---

## 핵심 아키텍처 요구사항

### 1. 데이터 관리 레이어 (PackedVector3Array)

**구현 요구사항:**
- 모든 동적 개체(비행기, 지상 유닛)의 상태를 PackedVector3Array로 관리
- 각 개체마다 필요한 배열:
  - `positions: PackedVector3Array` - 위치
  - `velocities: PackedVector3Array` - 속도
  - `rotations: PackedVector3Array` - 회전 (Euler 또는 방향 벡터)
  - `healths: PackedFloat32Array` - 체력 (옵션)

**처리 방식:**
- 프레임마다 배열을 순회하며 일괄 업데이트
- 배열 인덱스 = 유닛 ID로 사용
- 죽은 유닛은 배열에서 제거하지 말고 플래그로 비활성화 처리

**성능 목표:**
- 비행기: 500~1000대
- 지상 유닛: 5000~10000개
- 업데이트 시간: 프레임당 5ms 이하

---

### 2. 렌더링 레이어 (GPU Instancing)

**구현 요구사항:**
- MultiMeshInstance3D 사용 필수
- 유닛 타입별로 별도 MultiMesh 생성:
  - 비행기 타입별 (전투기, 폭격기 등)
  - 지상 유닛 타입별 (탱크, 트럭, 건물 등)
  - 지형 개체별 (나무, 바위, 풀 등)

**업데이트 방식:**
```
매 프레임:
1. PackedVector3Array에서 Transform 데이터 읽기
2. MultiMesh.set_instance_transform() 호출
3. 비활성화된 유닛은 화면 밖으로 이동 또는 스케일 0
```

**LOD 시스템:**
- 3단계 LOD 필수:
  - 근거리(0-500m): 고품질 모델
  - 중거리(500-2000m): 중품질 모델
  - 원거리(2000m+): 저품질 모델 또는 빌보드
- 거리 기반 자동 전환

**최적화 요구사항:**
- 프러스텀 컬링 활성화
- 오클루전 컬링 고려 (지형 뒤 개체)
- 드로우콜: 타입당 1회로 제한

---

### 3. 고급 연산 레이어 (GLSL Compute Shader)

**필수 구현 Compute Shader:**

#### A. 충돌 감지 Shader
```
입력: 모든 유닛의 위치, 반경
출력: 충돌 페어 리스트
알고리즘: Spatial hashing 또는 Grid-based
```

#### B. 파티클 시스템 Shader
```
대상: 미사일 연기, 총알 궤적, 폭발 효과
처리: 위치, 속도, 수명 업데이트
수량: 파티클 10만 개 이상 지원
```

#### C. 군집 AI Shader (옵션)
```
알고리즘: Boids (분리, 정렬, 응집)
적용: 편대 비행, NPC 그룹 이동
```

**Compute Shader 통합 방식:**
1. RenderingDevice로 버퍼 생성
2. PackedArray 데이터를 GPU 버퍼로 복사
3. Compute Shader 실행
4. 결과를 다시 PackedArray로 읽기
5. 비동기 처리 고려 (이전 프레임 결과 사용)

---

## 게임 시스템별 구현 지침

### 비행기 시스템

**물리 모델:**
- 간소화된 비행 역학 (양력, 항력, 추력)
- 주요 비행기만 정밀 시뮬레이션, 배경 AI는 단순화
- PackedVector3Array에서 일괄 계산

**조작 시스템:**
- 플레이어 비행기는 개별 노드로 관리
- 카메라 추적 및 입력 처리
- 나머지는 배열에서 AI로 제어

**무기 시스템:**
- 미사일/총알도 PackedArray로 관리
- Compute Shader로 궤적 계산
- 충돌 판정은 Compute Shader 활용

---

### 지형 시스템

**지형 구조:**
- Heightmap 기반 (Terrain3D 플러그인 권장)
- 타일 기반 스트리밍 (카메라 주변만 로드)
- 최소 10km x 10km 크기 지원

**지형 개체 (나무, 바위):**
- GPU Instancing으로 100만 개 이상 배치
- 절차적 생성 또는 미리 계산된 위치
- 충돌 감지는 근접한 개체만 활성화

**최적화:**
- 멀리 있는 지형은 텍스처 품질 낮춤
- 세부 개체는 거리에 따라 점진적 표시/숨김

---

### 지상 유닛 시스템

**유닛 분류:**
- 정적 개체 (건물, 벙커): StaticBody3D + Instancing
- 동적 개체 (탱크, 차량): PackedArray + Instancing
- 중요 목표물: 개별 노드로 관리

**AI 처리:**
- 간단한 상태 머신 (순찰, 추적, 공격)
- 경로 찾기는 미리 계산된 웨이포인트 사용
- 복잡한 경로는 Compute Shader로 전처리

**상호작용:**
- 비행기 무기로 파괴 가능
- 폭발 이펙트는 파티클 Compute Shader 활용

---

## 데이터 흐름 파이프라인

### 매 프레임 처리 순서

```
1. 입력 처리 (1ms)
   - 플레이어 입력 수집
   - AI 결정 (우선순위 큐 사용)

2. 물리 업데이트 (3-5ms)
   - PackedVector3Array 일괄 업데이트
   - 위치, 속도, 회전 계산
   - 간단한 충돌 감지 (AABB)

3. GPU Compute 작업 제출 (1ms)
   - 충돌 감지 Shader 실행
   - 파티클 업데이트 Shader 실행
   - 비동기 처리로 대기 없이 진행

4. 렌더링 준비 (2-3ms)
   - MultiMesh Transform 업데이트
   - LOD 레벨 결정
   - 컬링 처리

5. GPU Compute 결과 읽기 (1ms)
   - 이전 프레임 결과 수집
   - 충돌 이벤트 처리

6. 렌더링 (GPU 작업)
   - Instanced drawing
```

**총 CPU 시간 목표: 10-12ms (60fps 여유)**

---

## 최적화 체크리스트

### 필수 최적화
- [ ] MultiMesh를 타입별로 분리
- [ ] LOD 시스템 3단계 구현
- [ ] 프러스텀 컬링 활성화
- [ ] PackedArray 크기 미리 할당 (리사이징 방지)
- [ ] Compute Shader 비동기 처리

### 권장 최적화
- [ ] Spatial hashing으로 충돌 감지 최적화
- [ ] 오클루전 컬링 (지형 뒤 개체)
- [ ] 파티클 풀링 (재사용)
- [ ] AI 업데이트 주기 차등화 (멀리 있는 유닛은 느리게)
- [ ] 음향도 거리 기반 최적화

### 고급 최적화
- [ ] Job System으로 물리 계산 멀티스레딩
- [ ] GPU 버퍼 재사용 (매 프레임 생성 방지)
- [ ] 컬링 결과 캐싱
- [ ] 지형 타일 스트리밍 최적화

---

## 개발 단계별 마일스톤

### Phase 1: 프로토타입 (2주)
- 기본 비행 조작 구현
- 10~50대 비행기 배치
- 간단한 GPU Instancing 적용
- 기본 지형 생성

**성공 기준:** 50대 비행기 60fps 유지

### Phase 2: 스케일업 (3주)
- PackedVector3Array로 리팩토링
- 500대 비행기 테스트
- LOD 시스템 구현
- 기본 AI 추가

**성공 기준:** 500대 비행기 60fps 유지

### Phase 3: Compute Shader 통합 (3주)
- 충돌 감지 Shader 구현
- 파티클 시스템 Shader 구현
- 성능 프로파일링 및 최적화

**성공 기준:** 1000대 비행기 + 10만 파티클 60fps

### Phase 4: 지상 시스템 (2주)
- 지상 유닛 추가 (5000개)
- 지형 개체 배치 (100만 개)
- 상호작용 시스템

**성공 기준:** 전체 시스템 60fps 유지

### Phase 5: 폴리싱 (진행 중)
- 세부 최적화
- 게임플레이 밸런싱
- UI/UX 개선

---

## 성능 목표 및 벤치마크

### 최소 사양 목표
- CPU: 4코어 이상
- GPU: GTX 1060 / RX 580 급
- RAM: 8GB

### 성능 지표
- FPS: 60fps 안정적 유지
- 프레임 시간: 16.6ms 이하
- CPU 사용: 물리/로직 10ms 이하
- GPU 사용: 70% 이하
- 메모리: 4GB 이하

### 테스트 시나리오
1. **경전투:** 100대 비행기 교전
2. **중전투:** 500대 비행기 + 지상 유닛
3. **대전투:** 1000대 비행기 + 지상 폭격
4. **스트레스 테스트:** 최대 수량 + 폭발 효과

---

## 주의사항 및 제약

### 기술적 제약
- Compute Shader는 Vulkan 백엔드 필수 (OpenGL 미지원)
- 모바일/웹은 성능 제한 (별도 최적화 필요)
- CPU-GPU 동기화 비용 고려 (비동기 처리 권장)

### 디자인 제약
- 너무 많은 유닛은 시각적 혼란 초래
- 중요 개체(플레이어, 보스)는 명확히 구분
- UI 정보 과부하 방지 (레이더, 미니맵 활용)

### 디버깅 고려사항
- Compute Shader 디버깅 어려움 (단계적 검증 필요)
- 대규모 배열 디버깅 도구 부족 (로깅 시스템 구축)
- 프로파일링 도구 적극 활용 (Godot Profiler, RenderDoc)

---

## 추가 기능 제안 (선택)

### 네트워크 멀티플레이어
- 클라이언트 예측 및 서버 조정
- 상태 동기화는 중요 유닛만
- 배경 유닛은 로컬 시뮬레이션

### 리플레이 시스템
- 입력/이벤트 기록
- PackedArray 상태 스냅샷
- 타임라인 스크럽

### 모딩 지원
- 비행기/유닛 데이터 외부 파일
- 커스텀 Compute Shader 로딩
- 지형 에디터 제공

---

## 참고 자료 및 도구

### Godot 4 문서
- RenderingDevice API
- MultiMeshInstance3D
- PackedArray 최적화

### 외부 플러그인
- Terrain3D (지형 생성)
- Godot Jolt (물리 엔진 대안)

### 프로파일링 도구
- Godot 내장 Profiler
- RenderDoc (GPU 디버깅)
- Tracy Profiler (CPU 프로파일링)

---

## 요약: AI Agent가 반드시 지켜야 할 핵심 원칙

1. **모든 동적 개체는 PackedVector3Array로 관리** - 개별 노드 금지
2. **렌더링은 MultiMeshInstance3D로 일괄 처리** - 드로우콜 최소화
3. **복잡한 연산은 Compute Shader로 이관** - CPU 부담 감소
4. **LOD 시스템 필수** - 거리 기반 품질 조정
5. **비동기 처리 활용** - 프레임 시간 분산
6. **성능 목표 60fps 엄수** - 지속적 프로파일링
7. **확장 가능한 구조** - 유닛 수 증가에 대응

이 지침을 따르면 상업 게임 수준의 대규모 전투 게임을 Godot 4로 구현할 수 있습니다.